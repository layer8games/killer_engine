/*=========================================================================
The Matrix is meant to be mathematically sound. The functions found here
have been tested and are built according to linear algebra rules. The 

Matrices will be column major to ahdere to the format used within opengl, 
and only 4x4 Matrices will be supported. This is because I cannot find any 
useful reason to suport a dynamic type at this time. In the future if other
Matrices appear to be useful, this class will basically be copied and will
be turned into whatever other type of Matrix is needed, be it a 3x3 or 2x2
or whatever. This class will only be a 4x4.

A typedef will be created in the Atom.h that will allow an object of this 
class to be created by just calling "matrix" as a class. 

Constructors: There are several ways to create a Matrix with this class.

matrix(single value) will create a identiy matrix of said value. 

maxtrix(16 values) will create a matrix as intended. It can take an array
or the values themselves. 

For the construction of the orthographic or persepctive matricies, there
is a funcion that you call to return the specified matrix. 

Matrix::Orthographic(width, height, depth)

Matrix::Perspective(width, height, depth)

Features to add later:

Perspective is planned, not to be implemenated until later. 

Multiplication by Matrix. This needs to be check. 

Multiplication by Vector (one column matrix). This will be added later in 
the name of pragmatism. 

Transpose. This may be useful later, but now so much now. 

This is not free to use, and cannot be used without the express permission
of KillerWave or Layer8, or whatever I am called now.

Written by Maxwell Miller
=========================================================================*/
#ifndef MATRIX_H
#define MATRIX_H

#include <Atom.h>

template<typename T>
class Matrix {
private:
	//T* _elements[16];
	T _m00;
	T _m01;
	T _m02;
	T _m03;

	T _m10;
	T _m11;
	T _m12;
	T _m13;

	T _m20;
	T _m21;
	T _m22;
	T _m23;

	T _m30;
	T _m31;
	T _m32;
	T _m33;


public:
//=====Constructor like functions=====	
	Matrix(void) : _m00(0), _m01(0), _m02(0), _m03(0), 
				   _m10(0), _m11(0), _m12(0), _m13(0), 
				   _m20(0), _m21(0), _m22(0), _m23(0), 
				   _m30(0), _m31(0), _m32(0), _m33(0)
	{  }

/*
	There is an idea hear to store the members as an array. 
	This failed, I can't get it to work, and here are the 
	two ways that I have tried to get it all going. Maybe
	later I can work this shit out.

		_elements[0](0),
	  	_elements[1](0),
	  	_elements[2](0),
	  	_elements[3](0),

	  	_elements[4](0),
	    _elements[5](0),
	    _elements[6](0),
	    _elements[7](0),

	  	_elements[8](0),
	    _elements[9](0),
	    _elements[10](0),
	   	_elements[11](0),

	  	_elements[12](0),
	   	_elements[13](0),
	   	_elements[14](0),
	   	_elements[15](0) { 
		


		_elements[0]  = 0;
	  	_elements[1]  = 0;
	  	_elements[2]  = 0;
	  	_elements[3]  = 0;

	  	_elements[4]  = 0;
	    _elements[5]  = 0;
	    _elements[6]  = 0;
	    _elements[7]  = 0;

	  	_elements[8]  = 0;
	    _elements[9]  = 0;
	    _elements[10] = 0;
	   	_elements[11] = 0;

	  	_elements[12] = 0;
	   	_elements[13] = 0;
	   	_elements[14] = 0;
	   	_elements[15] = 0; 
	}
*/
	
	Matrix(T val) : _m00(val), _m01(0),   _m02(0),   _m03(0), 
				    _m10(0),   _m11(val), _m12(0),   _m13(0), 
				    _m20(0),   _m21(0),   _m22(val), _m23(0), 
				    _m30(0),   _m31(0),   _m32(0),   _m33(val)
	{  }
	
/*
	_elements[0](val),
		_elements[1](0),
		_elements[2](0),
		_elements[3](0),
			 
		_elements[4](0),
	 	_elements[5] (val),
	   	_elements[6](0),
	  	_elements[7](0),
	      
	 	_elements[8](0),
	  	_elements[9](0),
	  	_elements[10](val),
	  	_elements[11](0),
	      
		_elements[12](0),
	  	_elements[13](0),
	  	_elements[14](0),
	  	_elements[15](val)

		_elements[0]  = val;
		_elements[1]  = 0;
		_elements[2]  = 0;
		_elements[3]  = 0;
			 
		_elements[4]  = 0;
	 	_elements[5]  = val;
	   	_elements[6]  = 0;
	  	_elements[7]  = 0;
	      
	 	_elements[8]  = 0;
	  	_elements[9]  = 0;
	  	_elements[10] = val;
	  	_elements[11] = 0;
	      
		_elements[12] = 0;
	  	_elements[13] = 0;
	  	_elements[14] = 0;
	  	_elements[15] = val;
*/

/*
	There was planned a constructor that would take an array as an arg, 
	but I cannot get this to work. In the name of time, I am cutting this
	for now. Maybe later I'll figure this out one. 

	Matrix(T* elems[16]) : _m00(elems[0]),  _m01(elems[1]),  _m02(elems[2]),  _m03(elems[3]), 
				   		   _m10(elems[4]),  _m11(elems[5]),  _m12(elems[6]),  _m13(elems[7]), 
				   		   _m20(elems[8]),  _m21(elems[9]),  _m22(elems[10]), _m23(elems[11]), 
				   		   _m30(elems[12]), _m31(elems[13]), _m32(elems[14]), _m33(elems[15])
	{  }
	

	{
		_elements[0]  = elems[0];
		_elements[1]  = elems[1];
	    _elements[2]  = elems[2];
	    _elements[3]  = elems[3];

	  	_elements[4]  = elems[4];
	    _elements[5]  = elems[5];
	    _elements[6]  = elems[6];
	    _elements[7]  = elems[7];

	  	_elements[8]  = elems[8];
	    _elements[9]  = elems[9];
	    _elements[10] = elems[10];
	   	_elements[11] = elems[11];

	  	_elements[12] = elems[12];
	   	_elements[13] = elems[13];
	   	_elements[14] = elems[14];
	   	_elements[15] = elems[15]; 
	}
*/

	Matrix(T m00, T m01, T m02, T m03,
	   	   T m10, T m11, T m12, T m13,
	   	   T m20, T m21, T m22, T m23,
	   	   T m30, T m31, T m32, T m33) 
	: _m00(m00), _m01(m01), _m02(m02), _m03(m03), 
	  _m10(m10), _m11(m11), _m12(m12), _m13(m13), 
	  _m20(m20), _m21(m21), _m22(m22), _m23(m23), 
	  _m30(m30), _m31(m31), _m32(m32), _m33(m33)
	{  }
	
/*

	_elements[0](m00),
		_elements[1](m01),
		_elements[2](m02),
		_elements[3](m03),

  	  	_elements[4](m10),
  	    _elements[5](m11),
  	    _elements[6](m12),
  	    _elements[7](m13),

  	  	_elements[8](m20),
  	    _elements[9](m21),
  	    _elements[10](m22),
  	   	_elements[11](m23),

  	  	_elements[12](m30),
  	   	_elements[13](m31),
  	   	_elements[14](m32),
  	   	_elements[15](m33)
	{
		_elements[0]  = m00;
		_elements[1]  = m01;
		_elements[2]  = m02;
		_elements[3]  = m03;

  	  	_elements[4]  = m10;
  	    _elements[5]  = m11;
  	    _elements[6]  = m12;
  	    _elements[7]  = m13;

  	  	_elements[8]  = m20;
  	    _elements[9]  = m21;
  	    _elements[10] = m22;
  	   	_elements[11] = m23;

  	  	_elements[12] = m30;
  	   	_elements[13] = m31;
  	   	_elements[14] = m32;
  	   	_elements[15] = m33;
  	   	
	}
*/

	~Matrix(void) { }

	void MakeOrthographic(T width, T height, T depth) {
	  	T right  = width   / 2;
	  	T left   = -width  / 2;
		T top    = height  / 2;
		T bottom = -height / 2;
		T far    = depth   / 2;
		T near   = -depth  / 2;

	  	//Reset Matrix
		_m00 = 0;
		_m01 = 0;
	 	_m02 = 0;
		_m03 = 0;

		_m10 = 0;
		_m11 = 0;
		_m12 = 0;
		_m13 = 0;

		_m20 = 0;
		_m21 = 0;
		_m22 = 0;
		_m23 = 0;

		_m30 = 0;
		_m31 = 0;
		_m32 = 0;
		_m33 = 0

		//Diagnal
		_m00 = 2 / (right - left);
		_m11 = 2 / (top - bottom);
		_m22 = 2 / (near - far);
		_m33 = 1;

		//Vector to actually move by
		_m13 = (left + right) / (left - right);
		_m23 = (bottom + top) / (bottom - top);
		_m33 = (near + far)   / (far - near);

	}

//=====Accessor======

	T* GetElems(void) {
		T* elements = new T[16]{
			_m00, _m01, _m02, _m03,
			_m10, _m11, _m12, _m13,
			_m20, _m21, _m22, _m23,
			_m30, _m31, _m32, _m33
		};

		return elements;
	}
//=====Operator Overload=====
	Matrix& operator =(const Matrix* M);
};

#endif